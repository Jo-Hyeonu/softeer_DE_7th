Review

SQLite 세팅
	sqlite3 파이썬 기본 내장되어 있음
	별도 서버 없이 .db 로컬 파일에 데이터 관리
+ DB 연결 -> conn =  sqlite3.conntet("dbname.db")
+ cursor -> SQL 문을 실행하는 도구 (eg. cur = conn.cursor())
+  cur.excute(" ") -> sql 구문 실행
+ conn.commit() -> 변경사항 저장

SQL 문법 정리 -> notion


제한사항
+ pandas 사용 x
To-do 
+ ~~SQL Tutorials에서 Example을 하나씩 수행하고 그 결과를 노트북에 출력하세요.(https://www.w3schools.com/sql/default.asp 에서 예제 진행)~~
- ~~원하는 출력결과를 얻기 위해 필요하다면 적합한 Demo Table을 만들어야 합니다.~~


회고
+ Keep : 최대한 정답을 보지 않고 sql 문 작성하면서 진행함. sql 문법 notion에 정리함
+ Problem : 집중력이 떨어져서 초반 부분과 후반 부분 코드 작성하거나 노션 기록시 조금 대충 작성함.
+ Try : 끝까지 꼼꼼하게 하자

팀 회고
+ 팀미션 진행 시간 결정 (수 오후 4시 쯤)
+ etl 코드 함수화 잘하자, 주석 잘 달자



SQL 정리
### DML (데이터 조작어)

1. SELECT 
    
    ```jsx
    SELECT 컬럼명1, 컬럼명2
    FROM 테이블
    WHERE 조건식
    GROUP BY 그룹화할 컬럼
    HAVING 그룹조건
    OEDER BY 정렬 기준 컬럼 ASC|DESC;
    ```
    
2. INSERT
    
    ```jsx
    INSERT INTO 테이블명 (컬럼1, 컬럼2) VALUES (값1, 값2);
    
    eg.
    INSERT OR IGNORE INTO Customers (CustomerName, City, Country) VALUES ('Wolski','Walla', 'Poland')
    스키마 지정해서 넣으면 원하는 값만 넣을 수 있음 나머지는 NULL, CustomerID(PK)는 auto increment
    ```
    

1. UPDATE
    
    *WHERE절 필수!! 없으면 테이블 전체가 다 바뀜
    
    ```jsx
    UPDATE 테이블명 SET 컬럼1 = 값1 WHERE 조건;
    ```
    
2. DELETE
    
    *WHERE 절 필수 
    
    ```jsx
    DELETE FROM 테이블명 WHERE 조건;
    ```
    

### DDL (데이터 정의어 : 크알드턴)

1. CREATE
    
    ```jsx
    CREATE TABLE 테이블명 (컬럼명 데이터타입 PK이면 지정, ...);
    ```
    
2. ALTER (테이블 구조 변경 : 컬럼 추가, 삭제)
    
    ```jsx
    ALTER TABLE 테이블명 ADD 컬럼명 타입;
    ```
    
3. DROP (테이블 완전 삭제)
    
    ```jsx
    DROP TABLE 테이블명;
    ```
    
4. TURNCATE (테이블 구조는 남기고 데이터만 삭제)
    
    ```jsx
    TURNCATE TABLE 테이블명
    ```
    

### DCL (데이터 제어어 : DB 권한 제어)

1. GRANT (권한 부여)
    
    ```jsx
    GRANT SELECT ON 테이블명 TO 사용자 아이디
    ```
    
2. REVOKE (권환 회수)
    
    ```jsx
    REVOKE SELECT ON 테이블명 FROM 사용자 아이디
    ```
    

### TCL (트렌젝션 제어어)

1. COMMIT : 작업 내용 DB에 영구 적용
2. ROLLBACK : 마지막 commit 시점으로 돌림
3. SAVEPOINT : 롤백 할 지점 지정

### 집계함수

- COUNT (개수) : `SELECT COUNT(*) FROM 주문;`
- SUM (합계) : `SELECT SUM(매출) FROM 판매기록;`
- AVG (평균) : `SELECT AVG(점수) FROM 시험결과;`
- MAX/MIN (최대/최소) : `SELECT MAX(가격) FROM 상품;`
- GROUP BY (그룹화) : `SELECT 부서, COUNT(*) FROM 사원 GROUP BY 부서;`
- HAVING (그룹 조건) : `SELECT 부서 FROM 사원 GROUP BY 부서 HAVING COUNT(*) > 5;`

### 조인 함수

- INNER JOIN (교집합) : `SELECT * FROM 학생 JOIN 성적 ON 학생.ID = 성적.ID;`
- LEFT JOIN (왼쪽 기준) : `SELECT * FROM 고객 LEFT JOIN 주문 ON 고객.ID = 주문.고객ID;`
- RIGHT JOIN (오른쪽 기준) : `SELECT * FROM 사원 RIGHT JOIN 부서 ON 사원.부서ID = 부서.ID;`

### 특수 연산자 → WHERE 절에서 사용

- LIKE (패턴) : `WHERE 이름 LIKE '김%';` (김으로 시작하는 모든 데이터) ‘_’ → 아무 문자 하나
- IN (포함) : `WHERE 지역 IN ('서울', '경기');` (리스트 중 하나라도 일치)
- BETWEEN (범위) : `WHERE 날짜 BETWEEN '2023-01-01' AND '2023-12-31';`
- **E**XISTS (데이터 하나라도 존재 여부) : `SELECT * FROM 상품 WHERE EXISTS (SELECT 1 FROM 주문 WHERE 주문.상품ID = 상품.ID);`
- IS NULL (빈값 체크) : `WHERE 전화번호 IS NULL;` (값이 비어있는 경우)
- IS NOT NULL (값이 있음) : `WHERE 이메일 IS NOT NULL;` (값이 채워진 경우)

### UNION

여러 sql 문 합쳐서 결과가 중복되는 행은 제거하고 결과 Return

- 각 sql 문의 select한 컬럼 순서 같아야함
- 선택한 컬럼 수도 동일해야함

```jsx
select CustomerID FROM Customers
union
select CustomerID FROM Orders

>> Customers와 Orders에서 겹치는 CustomerID는 한번만 나옴
```

UNION ALL  → UNION에서 중복값 출력 해줌 

### ANY , ALL

any → 서브쿼리가 반환하는 값(여러 개)중 하나라도 조건에 맞으면

all → 서브쿼리가 반환하는 값(여러 개) 모두가 조건에 맞으면

### CASE

### NULL FUNCTION

1. COALESCE(값1, 값2, 값3, ..) → IFNULL 확장 버전 값1 없으면 값2 , 값2 없으면 값3 …
2. IFNULL(값1, 값2) → 값1이 널이면 값2 리턴

### Procedure

== 미리 정의한 SQL 구문 (like 함수)

<aside>
📖

NULL vs NOT IN

- NOT IN (NULL에 실패) : 리스트 안에 `NULL`이 하나라도 포함되면, 전체 결과가 무조건 **Empty(0건)**가 됩니다.
    - 예제: `WHERE ID NOT IN (1, 2, NULL);` → 결과: 없음 (NULL 때문에 비교 불가)
- NOT EXISTS (NULL에 안전) : 서브쿼리 결과에 `NULL`이 있어도 무시하고, 조건에 맞는 데이터를 정상 조회합니다.
    - 예제: `WHERE NOT EXISTS (SELECT ID FROM 테이블);` → 결과: 정상 출력
</aside>

<aside>
📖

ORDER BY 컬럼1, 컬럼2

컬럼1 기준으로 정렬하고 동순위이면 컬럼2 기준 정렬

컬럼1 ASC, 컬럼2 DESC 해도 마찬가지

*order by default는 오름차순

</aside>

<aside>
📖

HAVING vs WHERE

</aside>

*as → “min(price) as SmallestPrice” 하면 결과 출력 시 열 이름이 별칭으로 지정됨

*“<>” == “!=”